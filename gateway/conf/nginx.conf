# Nginx配置文件 - AI Gateway 2.0
# 基于OpenResty的动态网关配置

# 工作进程数
worker_processes auto;

    # 错误日志 - 输出到标准输出
    error_log /dev/stderr info;

    # 事件模块配置
    events {
        worker_connections 4096;
        use epoll;
    }

# HTTP模块配置
http {
    # DNS解析器配置（Docker 网络 DNS）
    resolver 127.0.0.11 valid=30s ipv6=off;
    
    # MIME类型
    include mime.types;
    default_type application/octet-stream;
    
    # 字符集设置 - 支持UTF-8中文字符
    charset utf-8;
    source_charset utf-8;

    # 日志格式
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for" '
                    '$request_time $upstream_response_time';

    log_format json escape=json '{
        "remote_addr":"$remote_addr",
        "remote_user":"$remote_user",
        "request":"$request",
        "status":$status,
        "body_bytes_sent":$body_bytes_sent,
        "http_referer":"$http_referer",
        "http_user_agent":"$http_user_agent",
        "http_x_forwarded_for":"$http_x_forwarded_for",
        "request_time":$request_time,
        "upstream_response_time":$upstream_response_time,
        "request_id":"$http_x_request_id"
    }';

    # 访问日志 - 输出到标准输出
    access_log /dev/stdout json;

    # 基础设置
    sendfile on;
    tcp_nopush on;
    tcp_nodelay on;
    keepalive_timeout 65;
    types_hash_max_size 2048;
    client_max_body_size 256M;

    # Gzip压缩
    gzip on;
    gzip_vary on;
    gzip_min_length 1024;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_types
        text/plain
        text/css
        text/xml
        text/javascript
        application/json
        application/javascript
        application/xml+rss
        application/atom+xml
        image/svg+xml;

    # 共享内存配置
    lua_shared_dict config_cache 10m; # 配置缓存
    lua_shared_dict rate_limit 50m; # 限流数据
    lua_shared_dict metrics 20m; # 监控指标
    lua_shared_dict session 30m; # 会话数据
    lua_shared_dict upstream_state 10m; # upstream状态管理

    # Lua设置 - 包含openssl模块路径
    lua_package_path '/etc/nginx/lua/?.lua;/usr/share/lua/common/?.lua;;';
    lua_code_cache on;
    lua_need_request_body on;

    # 初始化脚本
    init_by_lua_block {
        local init = require "core.init"
        local ok, err = init.init_config()
        if not ok then
            ngx.log(ngx.ERR, "Failed to initialize gateway: ", err)
            os.exit(1)
        end
    }

    # 定时任务 - 已禁用，只使用Config Center的定时同步
    # init_worker_by_lua_block {
    #     local scheduler = require "monitoring.scheduler"
    #     scheduler.start_all_tasks()
    # }

    # 服务器配置 - 所有配置都通过Lua动态获取
    server {
        listen 8080;
        server_name _;
        
        # 字符集设置 - 确保UTF-8支持
        charset utf-8;
        
        # 声明自定义变量
        set $upstream_backend "";

        # HTTP代理 - 用于内部HTTP请求
        location /_http_proxy {
            internal;
            proxy_pass http://$arg_target_host:$arg_target_port$arg_target_path;
            proxy_set_header Host $arg_target_host:$arg_target_port;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_connect_timeout 5s;
            proxy_send_timeout 10s;
            proxy_read_timeout 10s;
        }

        # Token计算服务代理 - 专门用于token计算
        location /_token_calc {
            internal;
            access_log off;
            content_by_lua_block {
                local json = require "utils.json"
                local http = require "utils.http"
                local core = require "core.init"
                
                -- 获取请求参数
                local text = ngx.var.arg_text or ""
                local model = ngx.var.arg_model or "Qwen3-8B"
                
                -- 获取token服务配置
                local token_config = core.get_config().token_service
                local token_service_url = token_config.url .. "/calculate"
                
                -- 构建token请求数据
                local token_request = {
                    text = text,
                    model_name = model
                }
                
                local request_json, json_err = json.encode(token_request)
                if not request_json then
                    ngx.log(ngx.WARN, "Failed to encode token request: ", json_err)
                    ngx.header.content_type = "application/json"
                    ngx.say(json.encode({
                        success = false,
                        error = "Failed to encode token request",
                        token_count = math.ceil(string.len(text) / 4)  -- 降级估算
                    }))
                    return
                end
                
                -- 调用外部token服务
                local token_response, err = http.post(token_service_url, request_json)
                if token_response and token_response.body then
                    local response_data, parse_err = json.decode(token_response.body)
                    if response_data and response_data.success then
                        ngx.header.content_type = "application/json"
                        ngx.say(json.encode({
                            success = true,
                            token_count = response_data.token_count or 0,
                            model = model
                        }))
                        return
                    else
                        ngx.log(ngx.WARN, "Token calculation response parse failed: ", parse_err or "Invalid response format")
                    end
                else
                    ngx.log(ngx.WARN, "Token calculation failed: ", err or "Unknown error")
                end
                
                -- 降级到简单估算
                local estimated_tokens = math.ceil(string.len(text) / 4)
                ngx.header.content_type = "application/json"
                ngx.say(json.encode({
                    success = true,
                    token_count = estimated_tokens,
                    model = model,
                    fallback = true
                }))
            }
        }

        # 健康检查
        location /health {
            access_log off;
            content_by_lua_block {
                local cjson = require "cjson"
                local health = require "monitoring.health"
                local health_status = health.check_health()
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(health_status))
            }
        }


        # 统计信息
        location /stats {
            access_log off;
            content_by_lua_block {
                local cjson = require "cjson"
                local health = require "monitoring.health"
                local metrics = require "monitoring.metrics"
                local stats = {
                    health = health.check_health(),
                    metrics = metrics.get_global_metrics()
                }
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode(stats))
            }
        }

        # Prometheus指标端点
        location /metrics {
            access_log off;
            content_by_lua_block {
                local metrics = require "monitoring.metrics"
                local prometheus_metrics = metrics.get_prometheus_metrics()
                ngx.header.content_type = "text/plain; version=0.0.4; charset=utf-8"
                ngx.say(prometheus_metrics)
            }
        }

        # 刷新配置
        location /refresh-config {
            access_log off;
            content_by_lua_block {
                local config_loader = require "config.loader"
                local success = config_loader.refresh_all_configs()
                
                ngx.header.content_type = "application/json"
                if success then
                    ngx.say(cjson.encode({
                        success = true,
                        message = "All configurations refreshed successfully"
                    }))
                else
                    ngx.status = 500
                    ngx.say(cjson.encode({
                        success = false,
                        error = "Failed to refresh configurations"
                    }))
                end
            }
        }

        # 任务状态 API（只读）
        location /tasks {
            access_log off;
            content_by_lua_block {
                local scheduler = require "monitoring.scheduler"
                local tasks = scheduler.get_task_list()
                local status = scheduler.get_task_status()
                
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode({
                    success = true,
                    message = "Scheduled tasks are running automatically",
                    tasks = tasks,
                    status = status
                }))
            }
        }

        # 动态路由 - 所有其他请求
        location / {
            access_by_lua_block {
                ngx.log(ngx.ERR, "=== ACCESS_BY_LUA: Starting access_by_lua_block ===")
                local router = require "routing.router"
                ngx.log(ngx.ERR, "=== ACCESS_BY_LUA: Router module loaded successfully ===")
                router.handle_request()
                ngx.log(ngx.ERR, "=== ACCESS_BY_LUA: Router handle_request completed ===")
            }
            
            # 流式响应Token监控和截断
            body_filter_by_lua_block {
                local policy_enforcer = require "auth.policy_enforcer"
                local chunk, truncated = policy_enforcer.monitor_streaming_tokens(ngx.arg[1])
                ngx.arg[1] = chunk
                if truncated then
                    ngx.arg[2] = true  -- 结束响应
                end
            }
            
            proxy_pass $upstream_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            proxy_set_header X-Request-ID $http_x_request_id;
            
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
            
            proxy_intercept_errors on;
            error_page 502 503 504 = @error_handler;
        }
        
        # 请求结束处理 - 已禁用，指标记录已移到access_by_lua阶段
        # log_by_lua_block {
        #     local router = require "routing.router"
        #     router.handle_request_end()
        # }

        # 错误处理
        location @error_handler {
            internal;
            content_by_lua_block {
                local status = ngx.status
                local error_messages = {
                    [502] = "Bad Gateway",
                    [503] = "Service Unavailable",
                    [504] = "Gateway Timeout"
                }
                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode({
                    error = "upstream_error",
                    message = error_messages[status] or "Unknown error",
                    status = status,
                    request_id = ngx.var.http_x_request_id
                }))
            }
        }
    }
} 