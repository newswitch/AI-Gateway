# 轻量级配置中心设计

## 1. 设计目标

### 1.1 核心需求
- **配置管理**: 支持配置的增删改查
- **动态更新**: 配置变更实时生效
- **版本控制**: 配置版本管理和回滚
- **权限控制**: 基于角色的配置访问控制
- **高可用**: 支持集群部署

### 1.2 技术选型
- **存储**: Redis + 文件系统
- **API**: RESTful API
- **协议**: HTTP/HTTPS
- **认证**: JWT Token
- **监控**: 内置健康检查和监控

## 2. 系统架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端管理界面    │    │   配置中心API    │    │   存储层        │
│   Vue 3 +       │◄──►│   Python        │◄──►│   Redis +       │
│   Element Plus   │    │   FastAPI       │    │   文件系统      │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                              │
                       ┌─────────────────┐
                       │   配置同步       │
                       │   WebSocket     │
                       └─────────────────┘
```

## 3. 核心功能设计

### 3.1 配置管理
```python
# 配置结构示例
{
    "config_id": "channel_wechat001",
    "namespace": "gateway",
    "group": "channel_config",
    "data": {
        "channel_code": "wechat001",
        "max_connections": 1000,
        "max_requests_per_minute": 100,
        "token_limits": {
            "10min": 10000,
            "20min": 15000,
            "30min": 20000
        },
        "enabled": true
    },
    "version": "1.0.0",
    "create_time": "2024-01-01T00:00:00Z",
    "update_time": "2024-01-01T00:00:00Z"
}
```

### 3.2 API设计
```python
# 配置管理API
GET    /api/v1/configs                    # 获取配置列表
GET    /api/v1/configs/{config_id}        # 获取单个配置
POST   /api/v1/configs                    # 创建配置
PUT    /api/v1/configs/{config_id}        # 更新配置
DELETE /api/v1/configs/{config_id}        # 删除配置

# 配置订阅API
GET    /api/v1/configs/{config_id}/watch  # 监听配置变更
POST   /api/v1/configs/{config_id}/notify # 配置变更通知

# 版本管理API
GET    /api/v1/configs/{config_id}/versions    # 获取版本历史
POST   /api/v1/configs/{config_id}/rollback    # 版本回滚
```

### 3.3 配置同步机制
```python
# WebSocket实时同步
class ConfigSync:
    def __init__(self):
        self.clients = {}  # 客户端连接池
        
    async def broadcast_config_change(self, config_id, new_config):
        """广播配置变更"""
        message = {
            "type": "config_change",
            "config_id": config_id,
            "data": new_config,
            "timestamp": datetime.now().isoformat()
        }
        
        for client_id, websocket in self.clients.items():
            try:
                await websocket.send_json(message)
            except Exception as e:
                # 移除断开的连接
                del self.clients[client_id]
```

## 4. 存储设计

### 4.1 Redis存储结构
```python
# 配置数据存储
config:{namespace}:{group}:{config_id} = {
    "data": "配置数据JSON",
    "version": "版本号",
    "create_time": "创建时间",
    "update_time": "更新时间"
}

# 配置索引
config:index:{namespace}:{group} = Set[config_id]

# 版本历史
config:history:{config_id} = List[版本数据]

# 客户端订阅
config:subscribers:{config_id} = Set[client_id]
```

### 4.2 文件系统备份
```python
# 配置文件结构
/configs/
├── namespace1/
│   ├── group1/
│   │   ├── config1.json
│   │   └── config2.json
│   └── group2/
│       └── config3.json
└── namespace2/
    └── group1/
        └── config4.json
```

## 5. 客户端集成

### 5.1 Nginx + Lua集成
```lua
-- 配置中心客户端
local config_client = {}

function config_client.get_config(config_id)
    local http = require("resty.http")
    local httpc = http.new()
    
    local res, err = httpc:request_uri("http://config-center:8000/api/v1/configs/" .. config_id, {
        method = "GET",
        headers = {
            ["Authorization"] = "Bearer " .. ngx.var.config_token
        }
    })
    
    if res and res.status == 200 then
        local cjson = require("cjson")
        return cjson.decode(res.body)
    end
    
    return nil, err
end

-- 配置变更监听
function config_client.watch_config(config_id, callback)
    local websocket = require("resty.websocket")
    local wb, err = websocket:new()
    
    if not wb then
        return nil, err
    end
    
    local uri = "ws://config-center:8000/api/v1/configs/" .. config_id .. "/watch"
    local ok, err = wb:connect(uri)
    
    if not ok then
        return nil, err
    end
    
    -- 监听配置变更
    while true do
        local data, typ, err = wb:recv_frame()
        if data then
            local cjson = require("cjson")
            local message = cjson.decode(data)
            if message.type == "config_change" then
                callback(message.data)
            end
        end
    end
end
```

### 5.2 Python客户端
```python
import asyncio
import aiohttp
import json
from typing import Dict, Any

class ConfigClient:
    def __init__(self, base_url: str, token: str):
        self.base_url = base_url
        self.headers = {"Authorization": f"Bearer {token}"}
        
    async def get_config(self, config_id: str) -> Dict[str, Any]:
        """获取配置"""
        async with aiohttp.ClientSession() as session:
            async with session.get(
                f"{self.base_url}/api/v1/configs/{config_id}",
                headers=self.headers
            ) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    raise Exception(f"Failed to get config: {response.status}")
    
    async def watch_config(self, config_id: str, callback):
        """监听配置变更"""
        async with aiohttp.ClientSession() as session:
            async with session.ws_connect(
                f"{self.base_url.replace('http', 'ws')}/api/v1/configs/{config_id}/watch",
                headers=self.headers
            ) as ws:
                async for msg in ws:
                    if msg.type == aiohttp.WSMsgType.TEXT:
                        data = json.loads(msg.data)
                        if data["type"] == "config_change":
                            callback(data["data"])
```

## 6. 部署方案

### 6.1 Docker部署
```yaml
# docker-compose.yml
version: '3.8'
services:
  config-center:
    build: .
    ports:
      - "8000:8000"
    environment:
      - REDIS_URL=redis://redis:6379
      - JWT_SECRET=your-secret-key
    depends_on:
      - redis
    volumes:
      - ./configs:/app/configs
      
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
      
volumes:
  redis_data:
```

### 6.2 Kubernetes部署
```yaml
# config-center-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: config-center
spec:
  replicas: 3
  selector:
    matchLabels:
      app: config-center
  template:
    metadata:
      labels:
        app: config-center
    spec:
      containers:
      - name: config-center
        image: config-center:latest
        ports:
        - containerPort: 8000
        env:
        - name: REDIS_URL
          value: "redis://redis-service:6379"
        - name: JWT_SECRET
          valueFrom:
            secretKeyRef:
              name: config-center-secret
              key: jwt-secret
---
apiVersion: v1
kind: Service
metadata:
  name: config-center-service
spec:
  selector:
    app: config-center
  ports:
  - port: 8000
    targetPort: 8000
  type: ClusterIP
```

## 7. 监控和运维

### 7.1 健康检查
```python
@app.get("/health")
async def health_check():
    """健康检查接口"""
    try:
        # 检查Redis连接
        redis_client.ping()
        
        # 检查文件系统
        os.access("/app/configs", os.R_OK)
        
        return {"status": "healthy", "timestamp": datetime.now().isoformat()}
    except Exception as e:
        return {"status": "unhealthy", "error": str(e)}
```

### 7.2 监控指标
```python
# Prometheus指标
from prometheus_client import Counter, Histogram, Gauge

# 配置操作计数
config_operations = Counter('config_operations_total', 'Total config operations', ['operation', 'namespace'])

# 配置变更延迟
config_change_duration = Histogram('config_change_duration_seconds', 'Config change duration')

# 活跃客户端数
active_clients = Gauge('active_clients', 'Number of active clients')
```

## 8. 优势总结

### 8.1 相比Nacos的优势
- **轻量级**: 只包含必要功能，资源消耗小
- **简单易用**: 学习成本低，维护简单
- **定制化**: 完全符合项目需求
- **性能优化**: 针对特定场景优化

### 8.2 适用场景
- 中小型项目
- 团队技术栈相对简单
- 对配置管理功能要求明确
- 希望减少外部依赖

## 9. 实施建议

### 9.1 开发优先级
1. **第一阶段**: 基础配置管理功能
2. **第二阶段**: 实时同步机制
3. **第三阶段**: 权限控制和监控
4. **第四阶段**: 高可用和性能优化

### 9.2 迁移策略
1. **并行运行**: 先部署自设计配置中心，与Nacos并行运行
2. **逐步迁移**: 逐步将配置从Nacos迁移到新配置中心
3. **验证测试**: 充分测试后切换
4. **完全切换**: 确认稳定后完全切换到新配置中心 